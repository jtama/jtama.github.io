---
layout: :theme/post
title: "OpenRewrite: Refactoring as code"
description: Introduction √† OpenRewrite
image: https://images.unsplash.com/photo-1589152144820-692b189e0b34?q=80&w=3474&auto=format&fit=crop&ixlib=rb-4.0.3
tags: java, tools
author: jtama
draft: true
---

image::{site.imagesDirUrl.resolve('openrewrite/logo.svg')}[Logo d'openrewrite]

icon:fa-lightbulb[]
_Mieux vaut pr√©venir que gu√©rir_, je n'utiliserai pas le mot _reusiner_, et certainement pas non plus le mot _refactoriser_. Cette note sera donc pleine d'anglicismes. La vie.


Alors comme √ßa vous voulez _refactor_ code ? Voici les diff√©rentes options qui s'offrent habituellement √† vous (je sais, il y en a d'autres) :

* Pour commencer le fameux (ou l'inf√¢me) *Chercher/Remplacer*, plus connu sous le nom de `Ctrl+F/Ctrl+R`.
* La technique un peu plus avanc√©e de l'expression r√©guli√®re, aussi connue sour le nom de _Les regexps c'est illisible 15 jours apr√®s les avoir √©crites_.
* Mais de fa√ßon plus probable, vous utiliserez le menu _click droit_ de votre IDE, ou un bon paquet de raccourcis clavier, technique √©galement connue sous le nom de _tu peux toujours courir, jamais tu reproduiras ce que j'ai fait_.

Si vous √™tes dans le cas d'un refactoring qui n√©cessite plus d'une √©tape et/ou qui touche √† de nombreux fichiers, vous √™tes tr√®s probablement condamn√© √† suivre un guide de migration, aussi triste qu'un long dimanche de pluie.


Disons que vous vouliez par exemple migrer de `JUnit 4` √† `JUnit 5`, ou bien de `Spring Boot 2` √† `Spring Boot 4`, ou  d'`Hibernate 4` √† `Hibernate 6`, ou encore de `Java 8` √† `Java 21`. Il vous faudrait pour cela :

. Faire les monter de versions dans vos fichiers de configuration `Maven` ou `Gradle`
. Changer vos imports
. Changer vos annotations
. Changer vos invocations de m√©thodes
. Peut-√™tre changer vous signature de m√©thodes
. Changer les noms de propri√©t√©
. Je ne sais quoi encore

C'est chronophage, lourd, sujet aux erreurs et aux oublis.

Mais il y a un petit nouveau dans le monde du refactoring : *OpenRewrite*.

== The big picture icon:fa-camera[]

OpenRewrite est un outil de refactoring qui a √©t√© cr√©√© par https://www.moderne.ai[Moderne].

C'est un projet open source sous licence Apache 2.0, et il fait maintenant partie de la https://www.commonhaus.org/[Fondation Commonhaus] pour une gouvernance plus ouverte.

Il a commenc√© avec un fort accent sur Java (et ses fichiers de configuration : properties et yaml), mais il s'√©tend maintenant √† d'autres langages et formats de fichiers :

* Langages de programmation : Java, Kotlin, Groovy
* Formats de donn√©es : XML, Properties, YAML, JSON, Protobuf
* Outils de build : Maven, Gradle

Je me concentrerai uniquement sur l'√©cosyst√®me Java dans cet article.

== Les concepts

Les principaux concepts d'OpenRewrite que vous devez garder √† l'esprit sont les suivants.

=== _Lossless Syntax Tree_

Le code source que vous souhaitez consulter et transformer est rendu accessible via un *_LST_*. C'est un arbre de syntax abstrait (*AST*) contenant en plus des information de formatage. Une repr√©sentation asbtraite du code source pour le rendre plus facile √† comprendre, √† interroger ou √† manipuler.

=== Recette icon:fa-utensils[]

Ou _recipe_ dans la langue de Shakespear est l'√©l√©ment atomique pour travailler sur le code. Elle peut contenir chacun des √©l√©ments suivants (tous √©tant optionnels):

* Un/des param√®tre(s) pour personnaliser le comportement de la recette.
* Une liste de pr√©-conditions, lui permettant de savoir si elle doit traiter un fichier source.
* Un _visitor_ qui permet d'effectuer ou non des modifications sur le code source.
* Une liste de recettes

Ce dernier point signifie que la fa√ßon d'impl√©menter un refactoring complexe est de composer des _recettes_, et √† la fin, cela s'appelle aussi une recette.

¬Ø\\_(„ÉÑ)_/¬Ø Ne bl√¢mez pas le messager.

=== Le pattern visitor icon:fa-spaghetti-monster-flying[]

Je l'ai mentionn√© juste au dessus, mais letraitement d'un recette passe par le pattern visitor. Chaque rencontre d'un √©l√©ment du _lst_ va g√©n√©r√© un __√©v√©nement__ qui sera transmis √† tous les visiteurs d√©clar√©s. Pour vous donner une id√©e, il y a actuellement 73 type d'√©v√©nements diff√©rent associ√© √† la _visite_ pour de code java, chacun associ√© √† des m√©thodes avec des signatures diff√©rentes.


== Qu'y a-t-il dans la bo√Æte icon:fa-gift[] ?

OpenRewrite est plus qu'un framework monolithique. Ces diff√©rents composants sont :

* Un module _core_, qui contient toute la repr√©sentation g√©n√©rique d'un LST et la logique de refactoring commune.
* Un module pour chaque langage, avec des API et SDK d√©di√©s pour une cible sp√©cifique (Java, XML, Yaml, etc).
* De nombreux modules contenant des recettes pour un sous-ensemble d'int√©r√™t sp√©cifique, telles que les recettes de frameworks de test, les recettes de Spring, les recettes de Quarkus, l'identification et la correction des probl√®mes d'analyse statique, etc.

== Le catalogue icon:fa-book-open[]

La grande puissance d'Openrewrite est la mise √† disposition recette d√©j√† disponible pour traiter un tr√®s grand nombre de cas sans que l'on ait √† produire la moindre ligne de code.
Il y a actuellement plus de 500 recettes disponibles pour Java, et il y en a probablement plus pour les autres langages et formats de fichiers.

Le catalogue est disponible en ligne √† l'adresse suivante : https://docs.openrewrite.org/recipes

Il contient toutes les recettes produites par l'√©quipe de Moderne, tri√©es par cat√©gories, document√©es et avec des exemples d'utilisation. Mais il contient √©galement d'autres sestions int√©ressantes. On y trouve par exemple une liste des recettes https://docs.openrewrite.org/popular-recipe-guides[les plus populaires], comme un acc√©l√©rateur de recherche, mais aussi une page d√©di√©e https://docs.openrewrite.org/reference/community-recipes[aux recettes √©crites par d'autre], comme _Apache Camel_, _AWS_, _Quarkus_, _Morphia_ et bien d'autres.

== Execution d'une recette icon:fa-cogs[]

Attaquons-nous √† la partie la plus simple de cette article : l'ex√©cution d'une recette. Petit pr√©requis: vous devez avoir `Maven` ou `Gradle` install√© sur votre machine. Que vous voulier ex√©cuter une recette qui concerne _Java_ ou _Kubernetes_, la proc√©dure est la m√™me. D√©sol√©.

Pour ex√©cuter une recette, vous avez deux options.

=== En modifiant vos descripteurs de build

Je vais prendre l'exemple d'un projet _Maven_, mais les √©tapes √† suivre sont les m√™mes pour un projet _Gradle_.

Pour commencer, vous devez ajouter le plugin `rewrite-maven-plugin` √† votre fichier `pom.xml` :

[source,xml]
----
<build>
  <plugins>
    <plugin><1>
      <groupId>org.openrewrite.maven</groupId>
      <artifactId>rewrite-maven-plugin</artifactId>
      <version>5.46.1</version><2>
    </plugin>
  </plugins>
</build>
----
<1> D√©claration du plugin
<2> Adapter le num√©ro pour utiliser la version la plus √† jour

Ensuite, vous devez d√©clarer la recette que vous voulez ex√©cuter. Ici par exemple la suppression de _Cobertura_ qui n'est plus compatible avec un projet _Java_ dont la version est sup√©rieure √† _Java 11_ :

[source,xml]
----
<build>
  <plugins>
    <plugin>
      <groupId>org.openrewrite.maven</groupId>
      <artifactId>rewrite-maven-plugin</artifactId>
      <version>5.46.1</version>
      <configuration> <1>
          <activeRecipes>
            <recipe>org.openrewrite.java.migrate.cobertura.RemoveCoberturaMavenPlugin</recipe> <2>
          </activeRecipes>
      </configuration>
    </plugin>
  </plugins>
</build>
----
<1> Configuration du plugin
<2> Activation de la recette

Ajout de la d√©pendance dans laquelle se trouve la recette (si elle n'est pas dans le module core), ce qui donne la configuration compl√®te suivante :

[source,xml]
----
<build>
  <plugins>
    <plugin>
      <groupId>org.openrewrite.maven</groupId>
      <artifactId>rewrite-maven-plugin</artifactId>
      <version>5.46.1</version>
      <configuration>
        <activeRecipes>
          <recipe>org.openrewrite.java.migrate.cobertura.RemoveCoberturaMavenPlugin</recipe>
        </activeRecipes>
      </configuration>
      <dependencies>
        <dependency>
          <groupId>org.openrewrite.recipe</groupId>
          <artifactId>rewrite-migrate-java</artifactId>
          <version>2.30.1</version>
        </dependency>
      </dependencies>
    </plugin>
  </plugins>
</build>
----

Pour ex√©cuter la recette, il suffit de lancer la commande suivante :

[source,console]
----
$ mvn rewrite:run
----

Mais on ne veut pas modifier nos fichiers de build, n'est-ce pas ? Et on ne se trouve peut-√™tre m√™me pas dans un projet _Maven_ ou _Gradle_.

=== Sans modifier vos descripteurs de build

Dans ce cas il est possible de pr√©ciser directement tout dans la ligne de commande, mais celle-ci deviendra forc√©ment plus complexe :

[source,console]
----
$ mvn -U org.openrewrite.maven:rewrite-maven-plugin:run	\<1>
   -Drewrite.recipeArtifactCoordinates=org.openrewrite.recipe:rewrite-java:2.30.1 \<2>
   -Drewrite.activeRecipes=org.openrewrite.java.migrate.cobertura.RemoveCoberturaMavenPlugin <3>
----
<1> D√©claration du plugin
<2> Ajout de la d√©pendance de la recette
<3> Activation de la recette

== Concevoir ses propres recettes

Les fa√ßons de faire d√©crites ci-dessus ne sont valables que si les recettes ne prennent pas de param√®tres. Si telle n'est pas le cas il va falloir passer √† l'√©tape suivante : la conception de recettes.

Pour concevoir ses propres recettes, le guide de bonne pratique d'Openrewrite nous dit que tout ce qui peut √™tre fa√Æt de mani√®re d√©clarative doit l'√™tre. Oui, je sais, c'est dur. Vous √™tes des d√©veloppeurs, vous voulez √©crire du code. Mais c'est comme √ßa.

Openrewrite nous offre pour cela un format de d√©claration de recette en _YAML_. Oh oui youpiiiii üíÉ icon:fa-dancer[].

== Recette d√©clarative (_Declarative recipe_)

Le format propos√© par Openrewrite pour recette d√©clarative permet d'assigner une sous partie de ce qui est possible en Java. Il n'est notamment pas possible d'ajouter des param√®tres, ni de renvoyer un visiteur dans une recette d√©clarative.

Voici un exemple de recette d√©clarative qui supprime la d√©pendance `com.github.jtama:toxic` d'un projet _Maven_. La recette doit-√™tre √©crite dans un fichier s'appelant `rewrite.yml` et se trouvant soit √† la racine du projet, soit dans le r√©pertoire `META-INF/rewrite` :

[source,yaml,highlight="3|4..10|11..13|14..17|23..24|26..34"]
----
---
type: specs.openrewrite.org/v1beta/recipe <1>
name: com.github.jtama.openrewrite.RemovesThatToxicDependency <2>
displayName: Removes that toxic dependency <3>
description: |
  Migrate from AcmeToxic ‚ò†Ô∏è to AcmeHealthy üòá,
  removes dependencies and migrates code.  <4>
tags: <5>
  - acme
  - toxic
recipeList: <6>
  - org.openrewrite.java.ChangeMethodTargetToStatic: <7>
      methodPattern: com.github.jtama.toxic.toxic.BigDecimalUtils valueOf(..)
      fullyQualifiedTargetTypeName: java.math.BigDecimal
  - org.openrewrite.maven.RemoveUnusedProperties:
      properties: .*toxic\.version
  - org.openrewrite.maven.RemoveDependency:
      groupId: com.github.jtama
      artifactId: toxic-library
  - com.github.jtama.openrewrite.VousAllezVoirCeQueVousAllezVoir
---
type: specs.openrewrite.org/v1beta/recipe
name: com.github.jtama.openrewrite.VousAllezVoirCeQueVousAllezVoir
displayName: √áa va vous √©pater
description: |
  Rech. proj. pr proj. priv. Self Dem. Brt. Poss. S‚Äôadr. √† l‚Äôh√¥. Mart
tags:
  - acme
preconditions:
  - org.openrewrite.text.Find: <8>
      find: com.github.jtama
recipeList:
  - com.github.jtama.openrewrite.RemoveFooBarUtilsIsEmpty
  - com.github.jtama.openrewrite.RemoveFooBarUtilsStringFormatted
  - com.github.jtama.openrewrite.UseObjectsCompare
----
<1> D√©claration du type de recette
<2> Nom de la recette
<3> Nom affich√© lors de l'ex√©cution de la recette
<4> Description de la recette
<5> Tags pour faciliter la recherche
<6> Liste des recettes √† ex√©cuter
<7> Passage de param√®tre √† une recette
<8> Un exemple de pr√©condition. icon:fa-warning[] Attention cette pr√©condition va s'ex√©cuter pour toutes les recettes de la liste.

Comme nous l'avons vu dans l'exemple pr√©c√©dent, permet de construire des recettes complexes en les composant les unes avec les autres.

Deux points d'attention sont √† noter :

. Le fichier doit s'appeler `rewrite.yml`, pas `rewrite.yaml`. üôÑ
. Pour que cette recette puisse s'ex√©cuter, les 3 recettes filles doivent √™tre accessibles dans le _classpath_

[source, console]
----
$ mvn -U org.openrewrite.maven:rewrite-maven-plugin:run	\
   -Drewrite.recipeArtifactCoordinates=com.github.jtama:toxic-library-remover:1.0.0 \
   -Drewrite.activeRecipes=com.github.jtama.openrewrite.RemovesThatToxicDependency
----

=== Distribution

Vous √™tes heureux de ce que vous avez fait, vous voulez partager votre recette avec le monde entier. Pour cela, il vous suffit de cr√©er un module _Maven_ ou _Gradle_ et de le publier. Chacun pourra d√®s lors utilisez √† loisir votre recette.