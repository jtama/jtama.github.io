---
title: To Gather or not to Gather? That is the question.
published: false
description: "Et si on codait des Gatherer ?"
tags: java,gatherer,preview
image: https://images.unsplash.com/photo-1530210124550-912dc1381cb8?q=80&w=3474&auto=format&fit=crop&ixlib=rb-4.0.3
author: jtama
---
:toc:
:toc-title: Table des matiÃ¨res

== Mais de quoi va-t-on parler ?

**De java**. Oui je prÃ©fÃ¨re le dire dÃ¨s le dÃ©but. Cet article va parler de **Java** !

image::https://cdn.svgporn.com/logos/java.svg[logo java]

Les `gatherers` sont le premier ajout d'**importance** Ã  lâ€™API `java.util.Streams`, depuis sa sortie, et on parle de **2014**. Cela signifie quâ€™il ne sâ€™Ã©tait pas passÃ© grand-chose depuis __environ longtemps__.
ArrivÃ©s en _preview_ en Java 22, ils le sont toujours en Java 24.

== Remise Ã  niveau

MÃªme si on ne va pas faire une revue complÃ¨te de l'_API_ `java.util.Streams`, je vous propose de commencer par un petit quizz, _tranquilles, posÃ©s_.

image::https://raw.githubusercontent.com/jtama/to-gather-or-not-to-gather/refs/heads/main/slides/images/quizz.png[Shakespeare posant une question]

=== Quiz 1/3

[source,java]
----
1 public class Quizz {
2    public static void main(String[] args) {
3        getPeople()
4            .map(person -> person.getName())
5            .toList();
6    }
7 }
----

Admettons que la mÃ©thode `getPeople` renvoie une instance de `stream` de 10 objets de type `Person`.

Ici, le code est simple, on applique la mÃ©thode `map` qui prend en paramÃ¨tre une `Function`, qui transforme une instance de `Person` en `String` en renvoyant le rÃ©sultat de la mÃ©thode `Person.getName()`.

La question est :

> Combien de fois la ligne 4 est-elle invoquÃ©e ?
>
> â‘  1 fois ?
>
> â‘¡ 10 fois ?
>
> â‘¢ Non JÃ©rÃ´me, elle n'est pas invoquÃ©e la ligne 4.
>
> â‘£ _It depends!_

.RÃ©ponse
[%collapsible]
====
Vous Ãªtes-vous dit quâ€™il y avait plusieurs bonnes rÃ©ponses ?

La bonne rÃ©ponse est:

> â‘£ _It depends!_

En rÃ©alitÃ©, la question Ã©tait mal posÃ©e. La question, aurait du Ãªtre :

> "Est-ce que la mÃ©thode `map` est invoquÃ©e une fois, 10 fois, ainsi  de suite ?" ou "Est-ce que la fonction qui est passÃ©e en paramÃ¨tre de la mÃ©thode `map` est invoquÃ©e ?"

La mÃ©thode `map`, est bien appelÃ©e une seule fois, par contre, la fonction qui lui est passÃ©e en paramÃ¨tre, elle, est bien invoquÃ©e 10 fois.

Il faut systÃ©matiquement diffÃ©rencier les mÃ©thodes de lâ€™API Stream, qui ne font que de la configuration de pipeline, et les fonctions/predicats/... quâ€™on leur passe.

====

=== Quiz 2/3

Bon, ok, on a compris. Ã€ partir de maintenant, la question portera systÃ©matiquement sur le nombre dâ€™invocations de la `Function` passÃ©e en paramÃ¨tre de la mÃ©thode `map`.

[source,java]
----
1 public class Quizz {
2   public static void main(String[] args) {
3        getPeople()
4            .map(person -> person.getName());
5    }
6 }
----

La question est :

> Combien de fois la ligne 4 est-elle invoquÃ©e ?
>
> â‘  1 fois ?
>
> â‘¡ 10 fois ?
>
> â‘¢ Non JÃ©rÃ´me, elle n'est pas invoquÃ©e la ligne 4.

.RÃ©ponse
[%collapsible]
====

La bonne rÃ©ponse est :

> â‘¢ _Non JÃ©rÃ´me, elle nâ€™est pas invoquÃ©e la ligne 4._

Dans un `stream`, il y a deux types dâ€™opÃ©rations :

* Des opÃ©rations intermÃ©diaires.
* Des opÃ©rations finales.

Les opÃ©rations intermÃ©diaires ne font que configurer un pipeline dâ€™exÃ©cution, elles ne dÃ©clenchent rien. Tant quâ€™on nâ€™a pas appelÃ© une mÃ©thode finale sur un `stream`, il ne se passe rien du tout.
====

=== Quiz 3/3

[source,java]
----
1 public class Quiz {
2     public static void main(String[] args) {
3         getPeople()
4             .map(person -> person.getName())
5             .count();
6     }
7 }
----

La question est :

> Combien de fois la ligne 4 est-elle invoquÃ©e ?
>
> â‘  1 fois ?
>
> â‘¡ 10 fois ?
>
> â‘¢ Non JÃ©rÃ´me, elle n'est pas invoquÃ©e la ligne 4.


.RÃ©ponse
[%collapsible]
====

La bonne rÃ©ponse est :

> â‘¢ _Non JÃ©rÃ´me, elle nâ€™est pas invoquÃ©e la ligne 4._

Eeeeeeet oui, lâ€™API `stream` est intelligente, et parmi les opÃ©rations terminales, il y en a  certaines qui possÃ¨dent des _shortcuts_. Et c'est le cas de la mÃ©thode `count` qui est capable dâ€™Ã©valuer si toutes les opÃ©rations qui ont Ã©tÃ© exÃ©cutÃ©es avant elle peuvent avoir un impact sur la cardinalitÃ© de ce quâ€™il y a en sortie.

Ici, une seule opÃ©ration `map` nâ€™aura aucun impact sur la cardinalitÃ©, et donc, inutile de lâ€™invoquer, Ã§a nâ€™a aucun intÃ©rÃªt. On nâ€™a pas besoin de transformer des personnes en chaÃ®nes de caractÃ¨res pour savoir quâ€™il y en Ã  10.

C'est assez important de comprendre que vous n'avez pas de garantie d'invocation. Et si, par exemple, vous faites partie de la team `peek`-
<span style="color:"#EF0107">ğŸ’€ ARRÃŠTEZ-CA MAINTENANT ğŸ’€</span>-, et que vous utilisez un `count`, votre `peek` risquerait bien de ne jamais Ãªtre invoquÃ©.
====

== Rappels


* Il y a des mÃ©thodes intermÃ©diaires : `map`, `filter`, etc.
* Il y a des mÃ©thodes terminales : `anyMatch`, `toList`, `count`, etc.
Lâ€™invocation dâ€™une opÃ©ration terminale est le seul dÃ©clencheur de lâ€™utilisation dâ€™un pipeline. Je peux enchaÃ®ner autant dâ€™opÃ©rations intermÃ©diaires, il ne se passera jamais rien.
+
Et dÃ¨s que jâ€™appelle une opÃ©ration terminale, je consomme mon stream, et je ne peux plus rien en faire. Et Ã©videmment, un peu tautologique, je ne peux pas avoir deux mÃ©thodes terminales qui sâ€™enchaÃ®nent.
* Certaines opÃ©rations terminales possÃ¨dent des courts-circuits. 
* On peut implÃ©menter un nombre infini â™¾ï¸ d'opÃ©rations terminales grÃ¢ce Ã  l'API Collector.

***Ã‰videmment, lâ€™API gatherer est lÃ  pour rattraper cette terrible injustice et nous laisser la capacitÃ© de coder toutes les opÃ©rations intermÃ©diaires que lâ€™on veut.***

== Collectors vs Gatherers

Nous sommes habituÃ©s Ã  l'API `Collectors`, mais tout de mÃªme rafraÃ®chissons nous la mÃ©moire.

=== Les _Collectors_

[source,java]
----
Collector collector;<1>

Collectors.groupingBy(...);<2>

stream.collect(collector);<3>
----
<1> L'interface `Collector` que nous devons implÃ©menter.
<2> La classe `Collectors`, qui fourni un certain nombre de _collectors_ dÃ©jÃ  implÃ©mentÃ©s
<3> L'utilisation d'un _collector_ via la mÃ©thode `Stream#collect`

Et maintenant leurs jumeaux

=== Les _Gatherers_

[source,java]
----
Gatherer gatherer;<1>

Gatherers.windowFixed(...);<2>

stream.gather(gatherer);<3>
----
<1> L'interface `Gatherer` que nous devons implÃ©menter.
<2> La classe `Gatherers`, qui fourni un certain nombre de _gatherers_ dÃ©jÃ  implÃ©mentÃ©s. Ici `windowFixed` qui accumule _n_ Ã©lÃ©ments avant de les pousser dans le `stream` sous forme de liste.
<3> L'utilisation d'un _gatherer_ via la mÃ©thode `Stream#gather`

== Code utilisÃ© pour les exemples

Ã€ partir de maintenant, tous les exemples suivront le code suivant

[source,java]
----

public void main() throws IOException {
    Stream<Oeuvre> oeuvres = Reader.read().stream();
    prettyPrint(
       oeuvres.gather(
          filter(oeuvre -> oeuvre.titre().contains("N")) <1>
       )
    );
}

public record Oeuvre(
   String titre, 
   Integer anneeParution, 
   boolean perdue) {
}
----
<1> C'est ici que nous placerons les gatherer _custom_

== L'interface `Gatherer`

[NOTE]
====
Le code que nous allons regarder n'est pas le vrai code, mais une version Ã©purÃ©e de l'interface.
Si vous voulez voir le vrai code, je rappelle que link:https://github.com/openjdk/jdk/blob/master/src/java.base/share/classes/java/util/stream/Gatherer.java[tout ceci est libre d'accÃ¨s]
====

[source,java]
----
package java.util.stream;

public interface Gatherer<T, A, R> {

    default Supplier<A> initializer(); <1>

    Integrator<A, T, R> integrator(); <2>

    default BinaryOperator<A> combiner(); <3>

    default BiConsumer<A, Downstream<? super R>> finisher(); <4>
}
----

On peut dÃ©jÃ  constater que l'interface fait une utilisation massive des gÃ©nÃ©riques.

Pour les illustrer, nous allons prendre l'exemple d'un _gatherer_ qui rÃ©implÃ©mente l'opÃ©ration intermÃ©daire `map` (d'une instance d'`Oeuvre` vers une `String` en utilisant la mÃ©thode `Oeuvre#titre()`.

Le type `T` reprÃ©sente le type de l'objet entrant, ici `Oeuvre`. Le type `A` reprÃ©sente le type de l'Ã©tat du _gatherer_ (on y reviendra). Le type `R`reprÃ©sente le type de retour du _gatherer_, ici `String`.

=== â‘  La mÃ©thode `initializer`

Elle permet d'initialiser l'Ã©tat, si besoin. Elle possÃ¨de une implÃ©mentation par dÃ©faut et renvoie un `Supplier` d'Ã©tat.

[CAUTION]
Attention, elle ne renvoie pas un nouvel Ã©tat, mais un `Supplier` d'Ã©tat.

=== â‘¡ La mÃ©thode `integrator`

Son rÃ´le est de retourner un `Integrator`. C'est l'objet qui va intervenir sur le stream, et sur lequel nous allons revenir tout au long des exemples.

[CAUTION]
Attention, encore une fois, elle n'implÃ©mente pas la mÃ©thode qui agit. C'est une _factory_.

=== â‘¢ La mÃ©thode `combiner`

Elle renvoie un `BinaryOperator<X>`, c'est Ã  dire, une `BiFunction<X,X,X>`. Son rÃ´le est de combiner les Ã©tats en cas d'exÃ©cutions parallÃ¨les.

=== â‘£ La mÃ©thode `finisher`

Elle renvoie un `BinaryConsumer`, qui permet en cas de besoin d'exÃ©cuter une action en fin de traitement.

== Let's code !

> _Oui, ok, t'es mignon, mais c'est quand mÃªme super abstrait ce que tu nous racontes lÃ ._

Et c'est vrai !

Je vous propose donc de redÃ©velopper la mÃ©thode `filter` dont vous connaissez dÃ©jÃ  le fonctionnement.

=== On recode la mÃ©thode `filter`

C'est un `gatherer` simple, donc nous n'aurons besoin que d'implÃ©menter la mÃ©thode `integrator`.

Nous allons l'implÃ©menter Ã  base d'_anonymous inner class_. Ã€ l'ancienne.

[source,java]
----
package org.github.jtama.gatherornot;

import java.util.function.Predicate;
import java.util.stream.Gatherer;

public class Filter implements Gatherer<Oeuvre, Object, Oeuvre> {

    private final Predicate<Oeuvre> filter;

    Filter(Predicate<Oeuvre> filter) {
        this.filter = filter;
    }

    @Override
    public Integrator<Object, Oeuvre, Oeuvre> integrator() {
        return new Integrator<Object, Oeuvre, Oeuvre>() {
            @Override
            public boolean integrate( <4>
              Object state, <1>
              Oeuvre oeuvre, <2>
              Downstream<? super Oeuvre> downstream) { <3>
                if (filter.test(oeuvre)) {
                    return downstream.push(oeuvre);
                }
                return true;
            }
        };
    }
}
----
<1> L'Ã©tat que nous ignorons pour l'instant.
<2> L'instance d'`Oeuvre`en cours de traitement dans le `stream`.
<3> Le `downstream` reprÃ©sente ce qui vient aprÃ¨s dans le `stream`.
<4> La mÃ©thode retourne un `boolean` qui permet d'indiquer Ã  l'API `stream` si le gatherer accepte d'autres Ã©lÃ©ments. Comme, il s'agit d'un filtre, nous renvoyons toujours `true` ou la propogation du rÃ©sultat de la mÃ©thode `downstream.push`.

Ici, pas vraiment de difficultÃ©, mais un code vraiment verbeux que l'on va pouvoir simplifier.

L'implÃ©mentation de la classe `Integrator` ne contient qu'une mÃ©thode. On peut donc Ã©crire une lambda.

[source,java]
----
package org.github.jtama.gatherornot;

import java.util.function.Predicate;
import java.util.stream.Gatherer;

public class Filter implements Gatherer<Oeuvre, Object, Oeuvre> {

    private final Predicate<Oeuvre> filter;

    Filter(Predicate<Oeuvre> filter) {
        this.filter = filter;
    }

    @Override
    public Integrator<Object, Oeuvre, Oeuvre> integrator() {
        return (_, oeuvre, downstream) -> { <1>
            if (filter.test(oeuvre)) {
                return downstream.push(oeuvre);
            }
            return true;
        };
    }
}
----
<1> La variable `state` n'Ã©tant pas utilisÃ©e, on peux utiliser un `_`.

L'implÃ©mentation de la classe `Filter` ne contient Ã©galement qu'une mÃ©thode. Donc rebelote, transformation en lambda.

[source,java]
----
package org.github.jtama.gatherornot;

import java.util.function.Predicate;
import java.util.stream.Gatherer;

public class Filter {
    public static Gatherer<Oeuvre, ?, Oeuvre> filter(Predicate<Oeuvre> filter) {
        return () -> (_, oeuvre, downstream) -> {
            if (filter.test(oeuvre)) {
                return downstream.push(oeuvre);
            }
            return true;
        };
    }
}
----

Et voilÃ . C'est plus court. C'est mieux.

Non.

On a beaucoup perdu en lisibilitÃ©, mais les interfaces `Gatherer` et `Integrator` offrent des mÃ©thodes utilitaires pour la regagner.

[source,java]
----
package org.github.jtama.gatherornot;

import java.util.function.Predicate;
import java.util.stream.Gatherer;
import java.util.stream.Gatherer.Integrator;

public class Filter {
    public static Gatherer<Oeuvre, ?, Oeuvre> filter(Predicate<Oeuvre> filter) {
        return Gatherer.of(
                Integrator.ofGreedy(<1>
                    (_, oeuvre, downstream) -> {
                        if (filter.test(oeuvre)) {
                            return downstream.push(oeuvre);
                        }
                        return true;
                    }));
    }
}
----
<1> On utilise ici la mÃ©thode `ofGreedy` (pour ceux qui ne parlent pas couramment anglais, _greedy_ veut dire _avide_, allez tout de suite regarder le film **Se7en**), qui permet de dire Ã  l'API `stream` que ce `Gatherer` n'interrompra jamais de lui mÃªme la consommation du stream, et qui permet Ã  l'API `stream` de faire des optimisations.

Ã€ partir de maintenant, nous utiliserons toujours cette faÃ§on d'Ã©crire le code.


=== Un stream avec un index ?

N'avez-vous dÃ©jÃ  pas eu envie d'accÃ©der Ã  l'index de l'Ã©lÃ©ment en cours de traitement ? N'avez vous pas dÃ©jÃ  essayÃ© l'implÃ©mentation suivante ?

[source,java]
----
Stream<Oeuvre> oeuvres = Reader.read().stream();
AtomicInteger index = new AtomicInteger(0);<1>
oeuvres.map(value -> new Tuple<>(index.getAndIncrement(), value)));<2>
----
<1> On utilise un `AtomicInteger`pour conserver/incrÃ©menter l'index
<2> En admettant que la classe `Tuple`existe

C'est une approche qui fonctionne trÃ¨s bien jusqu'Ã  ce que quelqu'un ait la bonne idÃ©e d'ajouter un petit `.parallel()` avant.

Et lÃ  :
image::https://media1.giphy.com/media/v1.Y2lkPTc5MGI3NjExMXBhZnU4dWUxNDlicTJzNTdya3dramtlM3BoMXByZ2dwNGp4bnU5bCZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/iazocTLOsKzFS/giphy.gif[C'est le drame]

Bon je me permets d'ajouter qu'une bonne vieille boucle `for` est certainement ce qu'il vous faut.

Mais, pas d'inquiÃ©tude, on va pouvoir arranger Ã§a.

CommenÃ§ons par noter, que pour la premiÃ¨re fois depuis le dÃ©but de l'article nous allons avoir besoin de quelque chose pour maintenir l'Ã©tat.

Et comme l'API n'est pas trop mal faite, dans un `Gatherer`, le nom de ce concept est `state`. Â¯\\_(ãƒ„)_/Â¯

[source,java]
----
package org.github.jtama.gatherornot;

import java.util.stream.Gatherer;
import java.util.stream.Gatherer.Integrator;

public class WithIndex {

  public static Gatherer<Oeuvre, Counting, Tuple<Integer, Oeuvre>> withIndex() {

    return Gatherer.ofSequential( <3>
            () -> new Counting(), <1>
            Integrator.ofGreedy(
             (state, oeuvre, downstream) -> downstream.push(new Tuple<>(state.index++, oeuvre)))); <2>
  }

  static class Counting {
      int index;
  }
}
----
<1> Notre `Supplier` d'Ã©tat, ici une instance de la classe counting qui contient l'index
<2> L'implÃ©mentation est exactement la mÃªme
<3> On utilise la mÃ©thode `ofSequential`, qui permet d'interdire l'exÃ©cution du `gatherer`en parallel, mÃªme si le dÃ©veloppeur le demande.

=== Un `groupingBy`, mais pas terminal.

Pour rappel, la mÃ©thode `groupingBy` est une opÃ©ration finale, je vous encourage Ã  aller lire https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/stream/Collectors.html#groupingBy(java.util.function.Function)[la doc si vous voulez en savoir plus].

Ce que l'on cherche Ã  implÃ©menter c'est une opÃ©ration intermÃ©diaire qui va regrouper un ensemble cohÃ©rent d'Ã©lÃ©ment dans une liste avant de les relacher dans le stream.

Par exemple avec un stream contenant les oeuvres de _Shakespeare_ classÃ©es par date de parution, j'aimerai pouvoir regrouper les oeuvres par annÃ©es. Et tant qu'on y est, j'aimerais pouvoir l'utiliser pour d'autres objets, avec d'autres critÃ¨res de regroupement.

Cela signifie que nous allons faire un `Gatherer` gÃ©nÃ©rique.

Pour une fois, on va commencer en regardant l'utilisation !

[source,java]
----
Stream<Oeuvre> oeuvres = Reader.read().stream();
oeuvres.gather(series(Oeuvre::anneeParution)));<1>
----
<1> Je passe Ã  ma factory de `gatherer` un extracteur de clef.

Et maintenant l'implÃ©mentation :

[source,java]
----
package org.github.jtama.gatherornot;

import java.util.ArrayList;
import java.util.List;
import java.util.function.Function;
import java.util.stream.Gatherer;

public class Serie {

    public static <K,V> Gatherer<V, State, List<V>> series(Function<V,K> keyExtractor) {
        return Gatherer.ofSequential(<1>
                State::new,<2>
                Gatherer.Integrator.ofGreedy((state, value, downstream) -> {
                    // First invocation or the same key value
                    if (state.key == null || 
                            keyExtractor.apply(value).equals(state.key)) { <3>
                        state.values.add(value);
                        state.key = keyExtractor.apply(value);
                        return true;
                    }
                    var more = downstream.push(state.values); <4>
                    state.values = new ArrayList<>();
                    state.key = keyExtractor.apply(value);
                    state.values.add(value);
                    return more;
                }),
                (state, downstream) -> downstream.push(state.values));
    }

    public static class State<K,V> {
        private K key;
        private List<V> values = new ArrayList<>();
    }
}

----
<1> Oui on va rester en sÃ©quentiel, vous imaginez bien pourquoi.
<2> L'Ã©tat va maintenir la clef de regroupement et la liste pour l'accumulation des valeurs regroupÃ©es.
<3> Si c'est le premier tour de boucle ou que la valeur de regroupement est Ã©gale Ã  celle de l'Ã©tat, on accumule et rÃ©clame plus d'Ã©lÃ©ments.
<4> Sinon, on pousse les valeurs dÃ©jÃ  accumulÃ©es en conservant , et puis on reinitialise l'Ã©tat et on propage le retour de l'invocation de la mÃ©thode `downstream.push`.

Je me rend bien compte que ce `gatherer` est un peu plus compliquÃ©, mais l'avantage, c'est que si je veux regrouper mes Ã©lÃ©ments en fonction de la premiÃ¨re lettre du titre, je peux.

[source,java]
----
Stream<Oeuvre> oeuvres = Reader.read().stream();
oeuvres.sorted(Comparator.comparing(Oeuvre::titre))
        .gather(series(oeuvre -> oeuvre.titre().substring(0,1)));
----

Et Ã§a fonctionnerait mÃªme avec une hypothÃ©tique classe `Person`! Si je veux regrouper un `stream` de personne par annÃ©e de naissance :

[source,java]
----
Stream<Person> persons = Reader.read().stream();
persons.gather(series(Person::birthDate);
----

=== Et maintenant, on fusionne des `streams` !

Il n'est pas possible, simplement, Ã  ce jour de fusionner des `stream`. Ce que je veux je veux obtenir est l'Ã©quivalent du https://reactivex.io/documentation/operators/join.html[`join` de _RxJava_]

Mais en plus strict.

image::https://dev-to-uploads.s3.amazonaws.com/uploads/articles/k39zm4yfco6uyfda0jwl.png[Illustration du rÃ©sultat souhaitÃ©]

VoilÃ  comme Ã§a.

Plus prÃ©cisÃ©ment, je ne veux permettre que des paires complÃ¨tes.

On va reprendre le principe de commencer par l'utilisation.

[source,java]
----
Stream<Oeuvre> oeuvres = Reader.readUnordered().stream();
prettyPrint(oeuvres.gather(merge(streamToBeMerged)));
----


.Le code ci-dessus devait produire :
[%collapsible]
====

[source,shell]
----
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚Revue de presse           â”‚Titre                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚Beaucoup  de  bruits  pourâ”‚Peines d amour gagnÃ©es   â”‚
â”‚rien                      â”‚                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚Je ne m en  souviens  mÃªmeâ”‚Cardenio                 â”‚
â”‚plus.                     â”‚                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚Jamais entendu parler     â”‚La TempÃªte               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚NumÃ©ro  1  sept   semainesâ”‚Les Deux Gentilshommes deâ”‚
â”‚d affilÃ©es                â”‚VÃ©rone                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚Meilleure piÃ¨ce de l annÃ©eâ”‚Les Joyeuses CommÃ¨res  deâ”‚
â”‚                          â”‚Windsor                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚Un chef d oeuvre          â”‚Mesure pour mesure       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
----

====

Et maintenant l'implÃ©mentation :

[source,java]
----
package org.github.jtama.gatherornot;

import java.util.Iterator;
import java.util.stream.Gatherer;
import java.util.stream.Stream;

public class Merge {

  public static <T,Y> Gatherer<Y, Iterator<T>, Tuple<T, Y>> merge(Stream<T> stream) {
    return Gatherer.ofSequential(
            stream::iterator, <1>
            Gatherer.Integrator.of(
             (state, item, downstream) -> {
                if (state.hasNext()) <2>
                   return downstream.push(new Tuple<>(state.next(), item));
                return false; <3>
              }));
    }
}
----
<1> Pour savoir si il me reste quelque chose dans mon stream _"Ã  fusionner"_ je dois passer par un `iterator`, puisque que je ne peux directement faire un `Stream.hasNext`, ou `Stream.next`.
<2> Si mon stream _"Ã  fusionner"_ en a encore dans le ventre, on pousse au dowstream.
<3> Sinon on interrompt la consommation du `stream`. Je rappelle qu'on a dit qu'on ne voulait que des paires complÃ¨tes. Et puis c'est mon code, et je fais ce que je veux. Si vous voulez une autre implÃ©mentation, je ne vous empÃªche pas.

== On y va ou pas ?

Alors que cet article touche Ã  sa fin, j'espÃ¨re vous avoir montrÃ© qu'il existe en effet des cas pour lesquels les `Gatherer` vont nous permettre de rÃ©pondre Ã  de rÃ©els besoins. J'aimerais aussi attirer votre attention sur le fait que si ils ont mis autant de temps Ã  arriver, c'est certainement parce qu'on peut dÃ©jÃ  faire beaucoup avec l'existant, pourvu qu'on prenne le temps de regarder ce que l'on a dÃ©jÃ  Ã  disposition.

Vous trouverez dans le dÃ©pÃ´t github joint, tout le code prÃ©sentÃ© et mÃªme plus.

https://github.com/jtama/to-gather-or-not-to-gather[To gather or not to Gather]

Et surtout n'oubliez pas :

image::https://dev-to-uploads.s3.amazonaws.com/uploads/articles/89jg0fa71rsz387n9y1i.jpg[Rester curieux]
